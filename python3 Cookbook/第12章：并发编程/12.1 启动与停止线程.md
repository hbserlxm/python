

```python
import time,threading

def countdown(n):
    while n > 0:
        n -=1
        print(n)
        time.sleep(2)

def countdown1(n):
    while n > 0:
        n -=1
        print(n)
        time.sleep(2)

c= threading.Thread(target=countdown,args=(10,))
c1= threading.Thread(target=countdown1,args=(5,))
c.start()
c.join()
c1.start()
c1.join()

```
输出：
9，8，7，6...0,4,3,2,1,0
一个执行完后，才会执行另一个。

```pytyon
c.start()
c.join()
c1.start()
c1.join()
```
输出:
9 4 3 8 7 2 1 6 0 5 4 3 2 1 0
两个并行的。

## 总结：
* 可以用threading中的Thread来创建Thread对象，并通过target传入函数，还有args来传递函数需要的参数。

* 要通过start()方法来启动线程。会调用一个单独的系统线程来执行，一旦启动，将独立执行到函数返回。

* 可以用join()来加入当前线程。上面两种方式，返回结果不一样。

* 可以查看是否还在运行，
```python
if c.is_alive():
    print('still running.')
else:
    print('Complete.')
 ```

 * 需要长时间运行的，需要长时间运行的，可以设置为后台任务：
 ```python
 t = Thread(target=countdown, args=(10,), daemon=True)
t.start()
 ```
* 后台线程无法等待，在主线程终止的时候自动销毁。

* 除了start，join，is_alive，没有别的太多可以对线程做的，无法结束，发信号，调度，无法做更高级的操作，需要这些你需要自己添加。可以通过增加判断识别标志还有轮询来判断执行，通过这种办法来终止线程。

```python
from threading import Thread
import time

class countdown:
    def __init__(self):
        self.running = True

    def terminate(self):
        self.running = False

    def count(self,n):
        while self.running and n>0:
            n -=1
            print(n)
            time.sleep(5)

c=countdown()
t = Thread(target=c.count,args=(10,))
t.start()
c.terminate()
t.join()
```

* 一个线程阻塞在io操作上，他就永远无法返回，也就无法检查自己是否已经被结束，要终止这些操作，需要利用超时循环来操作线程。当超时的时候，进行下次循环。

```python
class countdown:
    def terminate(self):
        self.running = False

    def run(self,sock):
        sock.settimeout(5)
        while self.running:
            try:
                data = sock.recv(8129)
                break
            except sock.timeout:
                continue
        return 
```