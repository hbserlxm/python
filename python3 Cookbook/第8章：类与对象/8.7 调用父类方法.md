可以使用super()来调用父类的方法。

```python
class A(object):
    def spam(self):
        print('A')

class B(A):
    def spam(self):
        print('B')
        super().spam()

haha = B()
haha.spam()
```

输出结果是：

```python
B
A
```

super()函数常见的用法是在子类中确保父类被正常初始化了，为什么要在子类中初始化父类，因为在python中，当子类有初始化方法的时候会覆盖父类的初始化方法，父类的初始化方法在子类中是不会被自动调用的。
这里举个例子：
```python
class A(object):
    def __init__(self):
        self.color = 'black'
    def spam(self):
        print('A')
    def showcolor(self):
        print(self.color)

class B(A):
    def __init__(self):
        pass
    def spam(self):
        print('B')
        super().spam()

haha = B()
haha.showcolor()
```
这个时候结果就会报错`AttributeError: 'B' object has no attribute 'color'`这个是因为子类有了初始化的方法覆盖了父类的初始化，父类的初始化并不会自动的调用。
但是如果子类没有初始化方法，那么就会继承父类的初始化方法，那么程序就不会报错,如下：

```python
class A(object):
    def __init__(self):
        self.color = 'black'
    def spam(self):
        print('A')
    def showcolor(self):
        print(self.color)

class B(A):
    def spam(self):
        print('B')
        super().spam()

haha = B()
haha.showcolor()
```
输入的结果是`black`

比如说要用到父类中的一个方法，这个方法涉及到父类中的一个参数，但是这个参数是在父类的初始化方法中的，如果父类没有正常的初始化，那么子类实例调用该方法的时候就会报错没有该属性。详细可以参照印象笔记中的“Python中子类初始化父类构造方法”这篇文章

那么如果子类又要有自己的初始化方法，又要有父类的属性，上面一种情况该怎么解决呢？使用super()调用父类的初始化，如下：
```python
class A(object):
    def __init__(self):
        self.color = 'black'
    def spam(self):
        print('A')
    def showcolor(self):
        print(self.color)

class B(A):
    def __init__(self):
        super().__init__()
        pass
    def spam(self):
        print('B')
        super().spam()

haha = B()
haha.showcolor()
```
结果输出还是black，不会再报错B没有color属性了。




